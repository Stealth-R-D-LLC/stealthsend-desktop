# 101

## Bibliography and useful links

* generate seed, retrieve 12-word phrase, generate keys and addresses https://github.com/bitcoinjs/bitcoinjs-lib/issues/583
* bip32 explained https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki
* bit39 explained https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki
* address related methods https://github.com/bitcoinjs/bitcoinjs-lib/blob/master/test/integration/addresses.spec.ts
* react hd wallet example - https://medium.com/coinmonks/lets-create-a-secure-hd-bitcoin-wallet-in-electron-react-js-575032c42bf3
* keys, addresses, wallets - https://www.oreilly.com/library/view/mastering-bitcoin/9781491902639/ch04.html#:~:text=The%20bitcoin%20address%20is%20derived,of%20an%20arbitrary%2Dsized%20input.


## Useful explanations and common terms

* mnemonic (phrase) or seed recovery phrase -  a list of words which store all the information needed to recover Bitcoin funds on-chain. Wallet software will typically generate a seed phrase and instruct the user to write it down on paper. If the user's computer breaks or their hard drive becomes corrupted, they can download the same wallet software again and use the paper backup to get their bitcoins back

* seed - A seed in the cryptocurrency world is like a username-password combination to access your funds within a cryptocurrency wallet. Each seed is unique and extremely difficult to guess. These seeds are used to generate the keys used to sign transactions and generate the public address where the funds are stored.

* hd wallet - hierarchical determinstic wallets (or "HD Wallets"): wallets which can be shared partially or entirely with different systems, each with or without the ability to spend coins

* address - your wallet address. a source and/or destination for receiving/sending assets

* randomness - itchy topic. https://github.com/bitcoinjs/bitcoinjs-lib/blob/master/test/integration/addresses.spec.ts

* bip - Bitcoin Improvement Proposal

* bip32 - hd wallets 

* bip39 - implementation of a mnemonic code or mnemonic sentence -- a group of easy to remember words -- for the generation of deterministic wallets

## Keys, addresses, wallets

* the private and public keys are stored together as a key pair for convenience. However, the public key can be calculated from the private key, so storing only the private key is also possible
* A private key can be converted into a public key, but a public key cannot be converted back into a private key because the math only works one way.
* A bitcoin address is not the same as a public key. Bitcoin addresses are derived from a public key using a one-way function.
* Bitcoin addresses are almost always presented to users in an encoding called “Base58Check”
* The private key (k) is a number, usually picked at random. From the private key, we use elliptic curve multiplication, a one-way cryptographic function, to generate a public key (K). From the public key (K), we use a one-way cryptographic hash function to generate a bitcoin address (A).
* Ownership and control over the private key is the root of user control over all funds associated with the corresponding bitcoin address. The private key is used to create signatures that are required to spend bitcoins by proving ownership of funds used in a transaction. The private key must remain secret at all times
* Bitcoin wallets contain keys, not coins. Wallets are really keychains containing pairs of private/public keys. Users sign transactions with the keys, thereby proving they own the transaction outputs (their coins). The coins are stored on the blockchain in the form of transaction-ouputs (often noted as vout or txout).
* registered coin types - https://github.com/satoshilabs/slips/blob/master/slip-0044.md
![keys](https://miro.medium.com/max/700/0*k6AjMZgk1q8SCpdD.png)

* 


## HD wallet demo example with comments
```js
# https://git.barrage.net/barrage/hd-wallet-demo
'use strict';

const assert = require('assert');
const bitcoin = require('bitcoinjs-lib');
const wif = require('wif'); // wallet import format endocing/decodong

const network = {
    messagePrefix: '\x18Stealth Testnet Signed Message:\n',
    bech32: 'tb', // address format specified by BIP173
    bip32: { // address path. defines how to derive private and public keys of a wallet from a binary master seed (m) and an ordered set of indices
        public: 0x043587cf,
        private: 0x04358394,
    },
    pubKeyHash: 0x6f,
    scriptHash: 0xc4,
    wif: 0xef,
};

// const keyPair = bitcoin.ECPair.makeRandom({network: network});

function getAddress(node, network) {
    // p2pkh. This script pattern is used to “send” someone bitcoins
    // this function generates a new address on the specified newtork and returns it
    return bitcoin.payments.p2pkh({ pubkey: node.publicKey, network }).address;
}

// bip - Bitcoin Improvement Proposal

const bip39 = require('bip39'); // implementation of a mnemonic code or mnemonic sentence -- a group of easy to remember words -- for the generation of deterministic wallets
const bip32 = require('bip32'); // hierarchical determinstic wallets (or "HD Wallets"): wallets which can be shared partially or entirely with different systems, each with or without the ability to spend coins.

const mnemonic = 'excite attract off sugar mandate only captain chief follow celery elbow melt bone express cat loop mountain nephew';
//const mnemonic = bip39.generateMnemonic();
console.log(`Mnemonic: ${mnemonic}`);
console.log(`Validating mnemonic... ${bip39.validateMnemonic(mnemonic)}`);

const seed = bip39.mnemonicToSeedSync(mnemonic); // recovery seed of the master bip32 seed.
console.log(`Seed: ${seed.toString('hex')}`);
let root = bip32.fromSeed(seed, network); // general structure of hd wallet. it defines how to derive private and public keys of a wallet from a binary master seed (m) and an ordered set of indices (so called BIP32 path):
// m / index1 / index2 / ... / indexn 

// m’ / purpose’ / coin_type’ / account’ / change / address_index 
let child00 = root.derivePath("m/44'/1'/0'/0/0");
console.log(`Deriving ADDRESS from account 0, external 0, index 0: ${getAddress(child00, network)}`);
console.log(`Deriving PUBLIC KEY from account 0, index 0: ${child00.publicKey.toString('hex')}`);
console.log(`Deriving PRIVATE KEY from account 0, index 0: ${child00.privateKey.toString('hex')}`);
console.log('\n');
let child10 = root.derivePath("m/44'/1'/1'/0/0");
console.log(`Deriving ADDRESS from account 1, external 0, index 0: ${getAddress(child10, network)}`);
console.log(`Deriving PUBLIC KEY from account 1, external 0, index 0: ${child10.publicKey.toString('hex')}`);
console.log(`Deriving PRIVATE KEY from account 1, index 0: ${child10.privateKey.toString('hex')}`);
console.log('\n');
let child01 = root.derivePath("m/44'/1'/0'/0/1");
console.log(`Deriving ADDRESS from account 0, external 0, index 1: ${getAddress(child01, network)}`);
console.log(`Deriving PUBLIC KEY from account 0, external 0, index 1: ${child01.publicKey.toString('hex')}`);
console.log(`Deriving PRIVATE KEY from account 0, external 0, index 1: ${child01.privateKey.toString('hex')}`);
console.log('\n');
let account0 = root.derivePath("m/44'/1'/0'");
const account0xpub = account0.neutered().toBase58();
console.log(`Deriving EXTENDED ACCOUNT PUBLIC KEY from account 0: ${account0xpub}`);
let account1 = root.derivePath("m/44'/1'/1'");
const account1xpub = account1.neutered().toBase58();
console.log(`Deriving EXTENDED ACCOUNT PUBLIC KEY from account 1: ${account1xpub}`);
let account2 = root.derivePath("m/44'/1'/2'");
const account2xpub = account2.neutered().toBase58();
console.log(`Deriving EXTENDED ACCOUNT PUBLIC KEY from account 2: ${account2xpub}`);


/**
 * WARNING: “createrawtransaction” does not automatically create change outputs, so you can easily accidentally pay a
 * large transaction fee. For example, if our input had 20.0000 bitcoins and our output ($NEW_ADDRESS) is being paid
 * 19.9999 bitcoins, so the transaction will include a fee of 0.0001 bitcoins.
 * If we had paid $NEW_ADDRESS only 10 bitcoins with no other changes to this transaction, the transaction fee would be
 * a whopping 10 bitcoins.
 */
/**
 * curl --location --request POST 'http://195.29.45.123:46503' \
 *    --header 'Content-Type: application/json' \
 *    --header 'Authorization: Basic MDEwMTAxMDEwMTAxMDEwMTAxOjExMjIzMzQ0MTEyMjMzNDQ=' \
 *    --data-raw '{
 *       "jsonrpc": "2.0",
 *       "id": 1,
 *       "method": "getaddressoutputs",
 *       "params": ["mzyDjgXATnnvoXKy4BDByovZziiuYBBLNm", 1, 10]
 *   }'
 */
let getAddressOutputs = {
    "result": [
        {
            "height": 2382058,
            "vtx": 0,
            "vout": 0,
            "txid": "8b32fe81b06c4c0fb048c1ae785f3d614c575ae1d4f71dedab19933058be7348",
            "amount": 1.00000000,
            "blockhash": "8be6fd0275d3acdb9d9df248419a7369d283d7b161168d5b0b69e5ae64d02419",
            "confirmations": 86,
            "blocktime": 1592765329,
            "isspent": "false"
        }
    ],
    "error": null,
    "id": 1
};
let addressOutputs = getAddressOutputs.result;
let TransactionBuilder = bitcoin.TransactionBuilder;
let rawTransaction = new TransactionBuilder({network: network});
rawTransaction.addInput(addressOutputs[0].txid, addressOutputs[0].vout);
let recipient = {
    address: "",
    amount: 0.001
};
let change = {
    address: "mzyDjgXATnnvoXKy4BDByovZziiuYBBLNm",
    amount: 0.989
};
// add the output for recipient
rawTransaction.addOutput(recipient.address, recipient.amount);

// add the output for the change, send the change back to yourself.
// Outputs - inputs = transaction fee, so always double-check your math!
rawTransaction.addOutput(change.address, change.amount);

console.dir(rawTransaction);
```